//
//  sfnt.cpp
//  Scribus
//
//  Created by Andreas Vox on 18.04.15.
//
//

#include "fonts/sfnt.h"

#include FT_TRUETYPE_TABLES_H
#include FT_TRUETYPE_TAGS_H
#include FT_TRUETYPE_IDS_H

#include <QDebug>

namespace sfnt {
    
    uchar byte(QByteArray const & bb, uint pos)
    {
        const unsigned char * pp = reinterpret_cast<const unsigned char*>(bb.data()) + pos;
        return pp[0];
    }
    
    uint word(QByteArray const & bb, uint pos)
    {
        const unsigned char * pp = reinterpret_cast<const unsigned char*>(bb.data()) + pos;
        return pp[0] << 24 | pp[1] << 16 | pp[2] << 8 | pp[3];
    }
    
    void putWord(QByteArray & bb, uint pos, uint val)
    {
        unsigned char * pp = reinterpret_cast<unsigned char*>(bb.data()) + pos;
        *pp++ = (val >> 24) & 0xFF;
        *pp++ = (val >> 16) & 0xFF;
        *pp++ = (val >> 8) & 0xFF;
        *pp++ = (val) & 0xFF;
    }
    
    uint word16(QByteArray const & bb, uint pos)
    {
        const unsigned char * pp = reinterpret_cast<const unsigned char*>(bb.data()) + pos;
        return pp[0] << 8 | pp[1];
    }
    
    QByteArray tag(QByteArray const & bb, uint pos)
    {
        char buf[5] = "1234";
        buf[0] = bb.data()[pos];
        buf[1] = bb.data()[pos+1];
        buf[2] = bb.data()[pos+2];
        buf[3] = bb.data()[pos+3];
        return buf;
    }
    
    bool copy(QByteArray & dst, uint to, QByteArray & src, uint from, uint len)
    {
        if (!dst.data())
            return false;
        if (!src.data())
            return false;
        if (to + len > static_cast<uint>(dst.size()))
            return false;
        if (from + len > static_cast<uint>(src.size()))
            return false;
        
        memcpy(dst.data() + to, src.data() + from, len);
        return true;
    }
    


enum post_format {
    post_format10 = 0x00010000,
    post_format20 = 0x00020000,
    post_format25 = 0x00025000,
    post_format30 = 0x00030000,
    post_format40 = 0x00040000,
};

    
const uint post_format10_names_count = 258;

    
static const char* post_format10_names[] = {
    ".notdef",
    ".null",
    "nonmarkingreturn",
    "space",
    "exclam",
    "quotedbl",
    "numbersign",
    "dollar",
    "percent",
    "ampersand",
    "quotesingle",
    "parenleft",
    "parenright",
    "asterisk",
    "plus",
    "comma",
    "hyphen",
    "period",
    "slash",
    "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine",
    "colon",
    "semicolon",
    "less",
    "equal",
    "greater",
    "question",
    "at",
    "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
    "bracketleft",
    "backslash",
    "bracketright",
    "asciicircum",
    "underscore",
    "grave",
    "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
    "braceleft",
    "bar",
    "braceright",
    "asciitilde",
    "Adieresis",
    "Aring",
    "Ccedilla",
    "Eacute",
    "Ntilde",
    "Odieresis",
    "Udieresis",
    "aacute",
    "agrave",
    "acircumflex",
    "adieresis",
    "atilde",
    "aring",
    "ccedilla",
    "eacute",
    "egrave",
    "ecircumflex",
    "edieresis",
    "iacute",
    "igrave",
    "icircumflex",
    "idieresis",
    "ntilde",
    "oacute",
    "ograve",
    "ocircumflex",
    "odieresis",
    "otilde",
    "uacute",
    "ugrave",
    "ucircumflex",
    "udieresis",
    "dagger",
    "degree",
    "cent",
    "sterling",
    "section",
    "bullet",
    "paragraph",
    "germandbls",
    "registered",
    "copyright",
    "trademark",
    "acute",
    "dieresis",
    "notequal",
    "AE",
    "Oslash",
    "infinity",
    "plusminus",
    "lessequal",
    "greaterequal",
    "yen",
    "mu",
    "partialdiff",
    "summation",
    "product",
    "pi",
    "integral",
    "ordfeminine",
    "ordmasculine",
    "Omega",
    "ae",
    "oslash",
    "questiondown",
    "exclamdown",
    "logicalnot",
    "radical",
    "florin",
    "approxequal",
    "Delta",
    "guillemotleft",
    "guillemotright",
    "ellipsis",
    "nonbreakingspace",
    "Agrave",
    "Atilde",
    "Otilde",
    "OE",
    "oe",
    "endash",
    "emdash",
    "quotedblleft",
    "quotedblright",
    "quoteleft",
    "quoteright",
    "divide",
    "lozenge",
    "ydieresis",
    "Ydieresis",
    "fraction",
    "currency",
    "guilsinglleft",
    "guilsinglright",
    "fi",
    "fl",
    "daggerdbl",
    "periodcentered",
    "quotesinglbase",
    "quotedblbase",
    "perthousand",
    "Acircumflex",
    "Ecircumflex",
    "Aacute",
    "Edieresis",
    "Egrave",
    "Iacute",
    "Icircumflex",
    "Idieresis",
    "Igrave",
    "Oacute",
    "Ocircumflex",
    "apple",
    "Ograve",
    "Uacute",
    "Ucircumflex",
    "Ugrave",
    "dotlessi",
    "circumflex",
    "tilde",
    "macron",
    "breve",
    "dotaccent",
    "ring",
    "cedilla",
    "hungarumlaut",
    "ogonek",
    "caron",
    "Lslash",
    "lslash",
    "Scaron",
    "scaron",
    "Zcaron",
    "zcaron",
    "brokenbar",
    "Eth",
    "eth",
    "Yacute",
    "yacute",
    "Thorn",
    "thorn",
    "minus",
    "multiply",
    "onesuperior",
    "twosuperior",
    "threesuperior",
    "onehalf",
    "onequarter",
    "threequarters",
    "franc",
    "Gbreve",
    "gbreve",
    "Idotaccent",
    "Scedilla",
    "scedilla",
    "Cacute",
    "cacute",
    "Ccaron",
    "ccaron",
    "dcroat"
};



int PostTable::numberOfGlyphs() const
{
    if (names.length() > 0)
        return names.length();
    else
        return sfnt::post_format10_names_count;
}

QString PostTable::nameFor(uint glyph) const
{
    if (glyph < names.length())
    {
        return names[glyph];
    }
    else if (glyph < sfnt::post_format10_names_count)
    {
        return sfnt::post_format10_names[glyph];
    }
    else
    {
        return ".notdef";
    }
}


void PostTable::readFrom(FT_Face face)
{
    QByteArray postData;
    FT_ULong size = 0;
    int error = FT_Load_Sfnt_Table ( face, TTAG_post , 0, NULL, &size );
    qDebug() << "load post" << error << size;
    if (error)
    {
        errorMsg = "no post table";
        usable = false;
        return;
    }
    postData.resize(size);
    error = FT_Load_Sfnt_Table ( face, TTAG_post , 0, reinterpret_cast<FT_Byte*>(postData.data()), &size );
    if (error)
    {
        errorMsg = "can't load post table";
        usable = false;
        return;
    }
    
    switch (sfnt::word(postData, 0))
    {
        case sfnt::post_format10:
            usable = true;
            names.clear();
            return;
        case sfnt::post_format20:
            break;
        case sfnt::post_format25:
        case sfnt::post_format30:
        case sfnt::post_format40:
        default:
            errorMsg = QString("unsupported post format %1").arg(sfnt::word(postData,0));
            usable = false;
            return;
            
    }
    QMap<QString,uint> usedNames;
    QList<QByteArray> pascalStrings;
    
    const uint post_header_length = 32;
    uint nrOfGlyphs = sfnt::word16(postData, post_header_length);
    uint stringPos = post_header_length + 2 * nrOfGlyphs;
    while (stringPos < postData.length())
    {
        int strLen = sfnt::byte(postData,stringPos);
        ++stringPos;
        pascalStrings.append(postData.mid(stringPos, strLen));
        qDebug() << pascalStrings.length() << pascalStrings[pascalStrings.length()-1]
        stringPos += strLen;
    }
    uint pos = post_header_length + 2;
    for (int gid = 0; gid < nrOfGlyphs; ++gid)
    {
        uint nameIndex = sfnt::word16(postData, pos);
        pos += 2;
        QString name;
        if (nameIndex < sfnt::post_format10_names_count)
            name = sfnt::post_format10_names[nameIndex];
        else if (nameIndex < pascalStrings.length() + sfnt::post_format10_names_count)
            name = pascalStrings[nameIndex - sfnt::post_format10_names_count];
        else {
            usable = false;
            errorMsg = QString("missing name %1 for glyph %2").arg(nameIndex).arg(gid);
            return;
        }
        if (name != ".notdef" && name[0] != QChar(0) && usedNames.contains(name))
        {
            usable = false;
            errorMsg = QString("duplicate name %1 used for glyphs %2 and %3").arg(name).arg(gid).arg(usedNames[name]);
            return;
        }
        usedNames[name] = gid;
        names.append(name);
    }
    errorMsg = "";
    usable = true;
}

} // namespace sfnt


/// For GPOS lookups
enum ValueFormat
{
    XPlacement = 0x0001,
    YPlacement = 0x0002,
    XAdvance = 0x0004,
    YAdvance = 0x0008,
    XPlaDevice =0x0010,
    YPlaDevice =0x0020,
    XAdvDevice =0x0040,
    YAdvDevice =0x0080
};



KernFeature::KernFeature ( FT_Face face ) : m_valid ( true )
{
    FontName = QString (face->family_name) + " " + QString (face->style_name);
    // 	qDebug() <<"KF"<<FontName;
    // 	QTime t;
    // 	t.start();
    FT_ULong length = 0;
    if ( !FT_Load_Sfnt_Table ( face, TTAG_GPOS , 0, NULL, &length ) )
    {
        // 		qDebug() <<"\t"<<"GPOS table len"<<length;
        if ( length > 32 )
        {
            GPOSTableRaw.resize ( length );
            FT_Load_Sfnt_Table ( face, TTAG_GPOS, 0, reinterpret_cast<FT_Byte*> ( GPOSTableRaw.data() ), &length );
            
            makeCoverage();
        }
        else
            m_valid = false;
        
        GPOSTableRaw.clear();
        //		coverages.clear();
    }
    else
        m_valid = false;
    
    if (!m_valid)
        pairs.clear();
    // 	qDebug() <<"\t"<<m_valid;
    // 	qDebug() <<"\t"<<t.elapsed();
}

KernFeature::KernFeature ( const KernFeature & kf )
{
    m_valid = kf.m_valid;
    if ( m_valid )
        pairs = kf.pairs;
}


KernFeature::~ KernFeature()
{
}

double KernFeature::getPairValue ( unsigned int glyph1, unsigned int glyph2 ) const
{
    if (!m_valid)
        return 0.0;
    
    if (pairs.contains(glyph1) &&
        pairs[glyph1].contains(glyph2))
    {
        return pairs[glyph1][glyph2];
    }
    
    //qDebug()<<"Search in classes";
    foreach (const quint16& coverageId, coverages.keys())
    {
        // for each pairpos table, coverage lists covered _first_ (left) glyph
        if (!coverages[coverageId].contains(glyph1))
            continue;
        
        foreach(const quint16& classDefOffset, classGlyphFirst[coverageId].keys())
        {
            const ClassDefTable& cdt(classGlyphFirst[coverageId][classDefOffset]);
            foreach(const quint16& classIndex, cdt.keys())
            {
                const QList<quint16>& gl(cdt[classIndex]);
                if (!gl.contains(glyph1))
                    continue;
                //qDebug()<<"Found G1"<<glyph1<<"in Class"<<classIndex<<"at pos"<<gl.indexOf(glyph1);
                // Now we got the index of the first glyph class, see if glyph2 is in one of the left glyphs classes attached to this subtable.
                foreach(const quint16& classDefOffset2, classGlyphSecond[coverageId].keys())
                {
                    const ClassDefTable& cdt2(classGlyphSecond[coverageId][classDefOffset2]);
                    foreach(const quint16& classIndex2, cdt2.keys())
                    {
                        const QList<quint16>& gl2(cdt2[classIndex2]);
                        if (gl2.contains(glyph2))
                        {
                            //qDebug()<<"Found G2"<<glyph2<<"in Class"<<classIndex2<<"at pos"<<gl2.indexOf(glyph2);
                            
                            double v(classValue[coverageId][classIndex][classIndex2]);
                            // Cache this pair into "pairs" map.
                            pairs[glyph1][glyph2] = v;
                            return v;
                        }
                    }
                }
            }
        }
    }
    return 0.0;
}

void KernFeature::makeCoverage()
{
    if ( GPOSTableRaw.isEmpty() )
        return;
    
    quint16 FeatureList_Offset= toUint16 ( 6 );
    quint16 LookupList_Offset = toUint16 ( 8 );
    
    // Find the offsets of the kern feature tables
    quint16 FeatureCount = toUint16 ( FeatureList_Offset );
    QList<quint16> FeatureKern_Offset;
    for ( quint16 FeatureRecord ( 0 ); FeatureRecord < FeatureCount; ++ FeatureRecord )
    {
        int rawIdx ( FeatureList_Offset + 2 + ( 6 * FeatureRecord ) );
        quint32 tag ( FT_MAKE_TAG ( GPOSTableRaw.at ( rawIdx ),
                                   GPOSTableRaw.at ( rawIdx + 1 ),
                                   GPOSTableRaw.at ( rawIdx + 2 ),
                                   GPOSTableRaw.at ( rawIdx + 3 ) ) );
        if ( tag == TTAG_kern )
        {
            FeatureKern_Offset << ( toUint16 ( rawIdx + 4 ) + FeatureList_Offset );
        }
    }
    
    // Extract indices of lookups for feature kern
    QList<quint16> LookupListIndex;
    foreach ( quint16 kern, FeatureKern_Offset )
    {
        quint16 LookupCount ( toUint16 ( kern + 2 ) );
        for ( int llio ( 0 ) ; llio < LookupCount; ++llio )
        {
            quint16 Idx ( toUint16 ( kern + 4 + ( llio * 2 ) ) );
            if ( !LookupListIndex.contains ( Idx ) )
            {
                LookupListIndex <<Idx ;
            }
        }
    }
    
    
    // Extract offsets of lookup tables for feature kern
    QList<quint16> LookupTables;
    QList<quint16> PairAdjustmentSubTables;
    for ( int i ( 0 ); i < LookupListIndex.count(); ++i )
    {
        int rawIdx ( LookupList_Offset + 2 + ( LookupListIndex[i] * 2 ) );
        quint16 Lookup ( toUint16 ( rawIdx )  + LookupList_Offset );
        quint16 SubTableCount ( toUint16 ( Lookup + 4 ) );
        for ( int stIdx ( 0 ); stIdx < SubTableCount; ++ stIdx )
        {
            quint16 SubTable ( toUint16 ( Lookup + 6 + ( 2 * stIdx ) ) + Lookup );
            
            // 			quint16 PosFormat ( toUint16 ( SubTable ) );
            quint16 Coverage_Offset ( toUint16 ( SubTable + 2 ) + SubTable );
            quint16 CoverageFormat ( toUint16 ( Coverage_Offset ) );
            
            if ( 1 == CoverageFormat ) // glyph indices based
            {
                quint16 GlyphCount ( toUint16 ( Coverage_Offset + 2 ) );
                quint16 GlyphID ( Coverage_Offset + 4 );
                if (GlyphCount == 0) continue;
                
                for ( unsigned int gl ( 0 ); gl < GlyphCount; ++gl )
                {
                    coverages[SubTable] << toUint16 ( GlyphID + ( gl * 2 ) );
                }
            }
            else if ( 2 == CoverageFormat ) // Coverage Format2 => ranges based
            {
                quint16 RangeCount ( toUint16 ( Coverage_Offset + 2 ) );
                if (RangeCount == 0) continue;
                
                // 				int gl_base ( 0 );
                for ( int r ( 0 ); r < RangeCount; ++r )
                {
                    quint16 rBase ( Coverage_Offset + 4 + ( r * 6 ) );
                    quint16 Start ( toUint16 ( rBase ) );
                    quint16 End ( toUint16 ( rBase + 2 ) );
                    // 					quint16 StartCoverageIndex ( toUint16 ( rBase + 4 ) );
                    // #9842 : for some font such as Gabriola Regular
                    // the range maybe be specified in reverse order
                    if (Start <= End)
                    {
                        for ( unsigned int gl ( Start ); gl <= End; ++gl )
                            coverages[SubTable]  << gl;
                    }
                    else
                    {
                        for ( int gl ( Start ); gl >= (int) End; --gl )
                            coverages[SubTable]  << gl;
                    }
                }
            }
            else
            {
                //				qDebug() <<"Unknow Coverage Format:"<<CoverageFormat;
                continue;
            }
            
            makePairs ( SubTable );
        }
        
    }
    
    
}


void KernFeature::makePairs ( quint16 subtableOffset )
{
    /*
     Lookup Type 2:
     Pair Adjustment Positioning Subtable
     */
    
    quint16 PosFormat ( toUint16 ( subtableOffset ) );
    
    if ( PosFormat == 1 )
    {
        quint16 ValueFormat1 ( toUint16 ( subtableOffset +4 ) );
        quint16 ValueFormat2 ( toUint16 ( subtableOffset +6 ) );
        quint16 PairSetCount ( toUint16 ( subtableOffset +8 ) );
        if ( ValueFormat1 && ValueFormat2 )
        {
            for ( int psIdx ( 0 ); psIdx < PairSetCount; ++ psIdx )
            {
                int oldSecondGlyph = -1;
                unsigned int FirstGlyph ( coverages[subtableOffset][psIdx] );
                quint16 PairSetOffset ( toUint16 ( subtableOffset +10 + ( 2 * psIdx ) ) +  subtableOffset );
                quint16 PairValueCount ( toUint16 ( PairSetOffset ) );
                quint16 PairValueRecord ( PairSetOffset + 2 );
                for ( int pvIdx ( 0 ); pvIdx < PairValueCount; ++pvIdx )
                {
                    quint16 recordBase ( PairValueRecord + ( ( 2 + 2 + 2 ) * pvIdx ) );
                    quint16 SecondGlyph ( toUint16 ( recordBase ) );
                    qint16 Value1 ( toInt16 ( recordBase + 2 ) );
                    // #12475 : Per OpenType spec PairValueRecords must be sorted by SecondGlyph.
                    // If a kerning pair is duplicated, take only the first one into account
                    // for now. In the future we may have to ignore the GPOS table in such case.
                    // (http://partners.adobe.com/public/developer/opentype/index_table_formats2.html)
                    if (oldSecondGlyph >= SecondGlyph)
                        continue;
                    pairs[FirstGlyph][SecondGlyph] = double ( Value1 );
                    oldSecondGlyph = SecondGlyph;
                }
            }
        }
        else if ( ValueFormat1 && ( !ValueFormat2 ) )
        {
            for ( int psIdx ( 0 ); psIdx < PairSetCount; ++ psIdx )
            {
                int oldSecondGlyph = -1;
                unsigned int FirstGlyph ( coverages[subtableOffset][psIdx] );
                quint16 PairSetOffset ( toUint16 ( subtableOffset +10 + ( 2 * psIdx ) ) +  subtableOffset );
                quint16 PairValueCount ( toUint16 ( PairSetOffset ) );
                quint16 PairValueRecord ( PairSetOffset + 2 );
                for ( int pvIdx ( 0 ); pvIdx < PairValueCount; ++pvIdx )
                {
                    quint16 recordBase ( PairValueRecord + ( ( 2 + 2 ) * pvIdx ) );
                    quint16 SecondGlyph ( toUint16 ( recordBase ) );
                    qint16 Value1 ( toInt16 ( recordBase + 2 ) );
                    // #12475 : Per OpenType spec PairValueRecords must be sorted by SecondGlyph.
                    // If a kerning pair is duplicated, take only the first one into account
                    // for now. In the future we may have to ignore the GPOS table in such case.
                    // (http://partners.adobe.com/public/developer/opentype/index_table_formats2.html)
                    if (oldSecondGlyph >= SecondGlyph)
                        continue;
                    pairs[FirstGlyph][SecondGlyph] = double ( Value1 );
                    oldSecondGlyph = SecondGlyph;
                }
            }
        }
        else
        {
            //			qDebug() <<"ValueFormat1 is null or both ValueFormat1 and ValueFormat2 are null";
        }
    }
    else if ( PosFormat == 2 ) // class kerning
    {
        quint16 ValueFormat1 ( toUint16 ( subtableOffset +4 ) );
        quint16 ValueFormat2 ( toUint16 ( subtableOffset +6 ) );
        quint16 ClassDef1 ( toUint16 ( subtableOffset +8 )  + subtableOffset );
        quint16 ClassDef2 ( toUint16 ( subtableOffset +10 ) + subtableOffset );
        quint16 Class1Count ( toUint16 ( subtableOffset +12 ) );
        quint16 Class2Count ( toUint16 ( subtableOffset +14 ) );
        quint16 Class1Record ( subtableOffset +16 );
        
        // first extract classses
        getClass(true, ClassDef1 , subtableOffset );
        getClass(false, ClassDef2 , subtableOffset );
        
        if ( ValueFormat1 && ValueFormat2 )
        {
            for ( quint16 C1 ( 0 );C1 < Class1Count; ++C1 )
            {
                quint16 Class2Record ( Class1Record + ( C1 * ( 2 * 2 * Class2Count ) ) );
                for ( quint16 C2 ( 0 );C2 < Class2Count; ++C2 )
                {
                    qint16 Value1 ( toInt16 ( Class2Record + ( C2 * ( 2 * 2 ) ) ) );
                    if (Value1 != 0)
                    {
                        classValue[subtableOffset][C1][C2] = double ( Value1 );
                    }
                }
            }
        }
        else if ( ValueFormat1 && ( !ValueFormat2 ) )
        {
            for ( quint16 C1 ( 1 );C1 < Class1Count; ++C1 )
            {
                quint16 Class2Record ( Class1Record + ( C1 * ( 2 * Class2Count ) ) );
                for ( quint16 C2 ( 1 );C2 < Class2Count; ++C2 )
                {
                    qint16 Value1 ( toInt16 ( Class2Record + ( C2 * 2 ) ) );
                    if (Value1 != 0)
                    {
                        classValue[subtableOffset][C1][C2] = double ( Value1 );
                    }
                }
            }
        }
        else
        {
            //			qDebug() <<"ValueFormat1 is null or both ValueFormat1 and ValueFormat2 are null";
        }
        
    }
    else
        qDebug() <<"unknown PosFormat"<<PosFormat;
}

KernFeature::ClassDefTable KernFeature::getClass ( bool leftGlyph, quint16 classDefOffset, quint16 coverageId )
{
    if (leftGlyph)
    {
        if (classGlyphFirst.contains(coverageId) && classGlyphFirst[coverageId].contains(classDefOffset))
            return classGlyphFirst[coverageId][classDefOffset];
    }
    else
    {
        if (classGlyphSecond.contains(coverageId) && classGlyphSecond[coverageId].contains(classDefOffset))
            return classGlyphSecond[coverageId][classDefOffset];
    }
    
    ClassDefTable ret;
    
    QList<quint16> excludeList;
    quint16 ClassFormat ( toUint16 ( classDefOffset ) );
    if ( ClassFormat == 1 )
    {
        quint16 StartGlyph ( toUint16 ( classDefOffset +2 ) );
        quint16 GlyphCount ( toUint16 ( classDefOffset +4 ) );
        quint16 ClassValueArray ( classDefOffset + 6 );
        
        for ( quint16 CV ( 0 );CV < GlyphCount; ++CV )
        {
            excludeList<<StartGlyph + CV;
            ret[ toUint16 ( ClassValueArray + ( CV * 2 ) ) ] << StartGlyph + CV;
        }
    }
    else if ( ClassFormat == 2 )
    {
        quint16 ClassRangeCount ( toUint16 ( classDefOffset + 2 ) );
        quint16 ClassRangeRecord ( classDefOffset + 4 );
        for ( int CRR ( 0 ); CRR < ClassRangeCount; ++CRR )
        {
            quint16 Start ( toUint16 ( ClassRangeRecord + ( CRR * 6 ) ) );
            quint16 End ( toUint16 ( ClassRangeRecord + ( CRR * 6 ) + 2 ) );
            quint16 Class ( toUint16 ( ClassRangeRecord + ( CRR * 6 ) + 4 ) );
            
            if (Start <= End)
            {
                for ( int gl ( Start ); gl <= (int) End; ++gl )
                {
                    excludeList<< (quint16) gl;
                    ret[Class] << gl;
                }
            }
            else
            {
                for ( int gl ( Start ); gl >= (int) End; --gl )
                {
                    excludeList<< (quint16) gl;
                    ret[Class] << gl;
                }
            }
        }
    }
    else
        qDebug() <<"Unknown Class Table type";
    
    // if possible (all glyphs are "classed"), avoid to pass through this slow piece of code.
    if (excludeList.count() != coverages[coverageId].count())
    {
        foreach(const quint16& gidx, coverages[coverageId])
        {
            if (!excludeList.contains(gidx))
                ret[0] << gidx;
        }
    }
    if (leftGlyph)
        classGlyphFirst[coverageId][classDefOffset] = ret;
    else
        classGlyphSecond[coverageId][classDefOffset] = ret;
    
    return ret;
}

quint16 KernFeature::toUint16 ( quint16 index )
{
    if ( ( index + 2 ) > GPOSTableRaw.count() )
    {
        //                qDebug() << "HORROR!" << index << GPOSTableRaw.count() << FontName ;
        // Rather no kerning at all than random kerning
        // 		m_valid = false;
        return 0;
    }
    // FIXME I just do not know how it has to be done *properly*
    quint8 c1 ( GPOSTableRaw.at ( index ) );
    quint8 c2 ( GPOSTableRaw.at ( index + 1 ) );
    quint16 ret ( ( c1 << 8 ) | c2 );
    return ret;
}

qint16 KernFeature::toInt16 ( quint16 index )
{
    if ( ( index + 2 ) > GPOSTableRaw.count() )
    {
        return 0;
    }
    // FIXME I just do not know how it has to be done *properly*
    quint8 c1 ( GPOSTableRaw.at ( index ) );
    quint8 c2 ( GPOSTableRaw.at ( index + 1 ) );
    qint16 ret ( ( c1 << 8 ) | c2 );
    return ret;
}
